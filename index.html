
<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>HD Canvas</title>
	
</head>
<body>

<!-- <script src="./script.js"></script> -->
<script>
const {
	innerWidth: width,
	innerHeight: height,
	devicePixelRatio: dpr
} = window

console.log(width, height, dpr )

CanvasRenderingContext2D.prototype.getColor = function(color) {
	return "#" + color.replaceAll("#","")
}

CanvasRenderingContext2D.prototype.drawLine = function(x0=0, y0=0, x1=100, y1=100, width=5) {
	this.lineWidth = width
	this.beginPath()
	this.moveTo(x0, y0)
	this.lineTo(x1, y1)
	this.stroke()
}

CanvasRenderingContext2D.prototype.clear = function() {
	let w = this.canvas.width * 10
	let h = this.canvas.height * 10
	this.clearRect(0, 0, w, h)
}

CanvasRenderingContext2D.prototype.color = function(color, func) {
	if(!func) {
		this.fillStyle = this.getColor(color)
		this.strokeStyle = this.getColor(color)
		
		return
	}
	
	let before = this.fillStyle
	this.color(color)
	func()
	this.color(before)
	
}


function elem (value, tag = value) {
	let element = globalThis[value]
	
	if (!element && tag) {
		element = document.createElement(tag)
	}
	
	return element
}

function newCanvas(id, dx, dy, color, ratio = dpr) {
	const canvas = elem(id , "canvas")
	const ctx = canvas.getContext("2d")
	
	canvas.width = dx * ratio
	canvas.height = dy * ratio
	canvas.style.width = dx + "px"
	canvas.style.height = dy + "px"
	canvas.style.background = "#" + (color??"aaa").replaceAll("#","")
	canvas.style.boxSizeing = "border-box"
	
	ctx.setTransform(ratio, 0, 0, ratio, 0, 0)

	document.body.appendChild(canvas)
	
	return [ canvas, ctx ]
}

document.body.style.margin = 0
document.body.style.padding = 0

let [can,ctx] = newCanvas('can', width, width, "aaa", dpr )
//can.style.margin = "10px"





  
can.addEventListener('touchstart', function(e){
	
	let { clientX, clientY } = e.touches[0]
	console.log(clientX, clientY)
	ctx.drawLine(0,0,clientX,clientY)
})
/*
  can.addEventListener('touchend', handleEnd);
  can.addEventListener('touchcancel', handleCancel);
  can.addEventListener('touchmove', handleMove);
  */









let nn = 5

let an = 0

;(function loop() {
	//ctx.clear()
	update()
	requestAnimationFrame(loop)
})();



function update(){
let o = width/2

for(let i = width/nn; i < width; i += width/nn) {
	ctx.color("a0a2a4", () => {
		let n = 2
		ctx.drawLine( 0,i, width,i, n )
		ctx.drawLine( i,0, i,width, n )
	})
}

let t = an += 1 / 180
let l = o/2
ctx.drawLine( o,o, o+l*Math.sin(t), o+l*Math.cos(t) )
//ctx.drawLine( o,o, o+l*Math.sin(t+90), o+l*Math.cos(t) )

if (t== 0) ctx.clear();
}



function setupCanvas(canvas) {
  // Get the device pixel ratio, falling back to 1.
  var dpr = window.devicePixelRatio || 1;
  // Get the size of the canvas in CSS pixels.
  var rect = canvas.getBoundingClientRect();
  // Give the canvas pixel dimensions of their CSS
  // size * the device pixel ratio.
  canvas.width = width * dpr;
  canvas.height = width * dpr;
  canvas.style.width = width + "px"
canvas.style.height = width + "px"
canvas.style.background = "#ccc"
  var ctx = canvas.getContext('2d');
  // Scale all drawing operations by the dpr, so you
  // don't have to worry about the difference.
  ctx.scale(dpr, dpr);
  return ctx;
}

let c = elem("canvas")
//document.body.appendChild(c)
let cx = setupCanvas(c)
cx.drawLine(0,0,width,width)

cx.clearRect(0,0,width,width/1.5)

</script>
</body>
</html>




